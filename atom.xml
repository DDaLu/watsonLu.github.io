<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>watson&#39;blogs</title>
  
  
  <link href="https://watsonlu6.github.io/atom.xml" rel="self"/>
  
  <link href="https://watsonlu6.github.io/"/>
  <updated>2024-07-27T03:02:38.498Z</updated>
  <id>https://watsonlu6.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ceph体系架构</title>
    <link href="https://watsonlu6.github.io/Ceph%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <id>https://watsonlu6.github.io/Ceph%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</id>
    <published>2024-07-27T02:19:42.000Z</published>
    <updated>2024-07-27T03:02:38.498Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Ceph 官方定义</strong><br>Ceph is a unified, distributed storage system designed for excellent performance, reliability and scalability.(Ceph 是一种为优秀的性能、可靠性和可扩展性而设计的统一的、分布式的存储系统。)</p><p><strong>Ceph 设计思路</strong></p><ul><li><strong>充分发挥存储设备自身的计算能力。</strong> 采用具有计算能力的设备作为存储系统的存储节点。</li><li><strong>去除所有的中心点。</strong> 解决单点故障点和当系统规模扩大时出现的规模和性能瓶颈问题。</li></ul><p> <strong>Ceph的设计哲学</strong></p><ul><li>每个组件必须可扩展  </li><li>不存在单点故障</li><li>解决方案必须是基于软件的</li><li>可摆脱专属硬件的束缚即可运行在常规硬件上 </li><li>推崇自我管理</li></ul><p><strong>Ceph体系结构</strong><br>首先作为一个存储系统，Ceph在物理上必然包含一个存储集群，以及这个存储集群的应用或客户端。Ceph客户端又需要一定的协议与Ceph存储集群进行交互，Ceph的逻辑层次演化如图所示。<br><img src="/images/Ceph%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg"><br><strong>OSD</strong>：主要功能包括存储数据，处理数据的复制、恢复、回补、平衡数据分布，并将一些相关数据提供给Ceph Monitor。一个Ceph的存储集群，至少需要两个Ceph OSD来实现active+clean健康状态和有效的保存数据的双副本。一旦应用程序向ceph集群发出写操作，数据就以对象的形式存储在OSD中，OSD是Ceph集群中存储实际用户数据的唯一组件。通常，一个OSD守护进程绑定到集群中的一个物理磁盘。因此，通常来说，Ceph集群中物理磁盘的总数与在每个物理磁盘上存储用户数据的OSD守护进程的总数相同。</p><p><strong>MON</strong>：Ceph的监控器，主要功能是维护整个集群健康状态，提供一致性的决策。</p><p><strong>MDS</strong>：主要保存的是Ceph文件系统的元数据。（Ceph的块存储和对象存储都不需要Ceph MDS）</p><p><strong>RADOS</strong>：Ceph基于可靠的、自动化的、分布式的对象存储(<strong>R</strong>eliabl,<strong>A</strong>utonomous,<strong>D</strong>istributed <strong>O</strong>bject <strong>S</strong>torage, <strong>RADOS</strong> )提供了一个可无限扩展的存储集群，RADOS是Ceph最为关键的技术，它是一个支持海量存储对象的分布式对象存储系统。RADOS层本身就是一个完整的对象存储系统，事实上，所有存储在Ceph系统中的用户数据最终都是由这一层来存储。RADOS层确保数据始终保持一致，他执行数据复制、故障检测和恢复，以及跨集群节点的数据迁移和再平衡。 RADOS集群主要由两种节点组成：<em><strong>为数众多的OSD</strong></em>，负责完成数据存储和维护；<em><strong>若干个Monitor</strong></em>，负责完成系统状态检测和维护。OSD和Monion之间互相传递节点的状态信息，共同得出系统的总体运行状态，并保存在一个全局数据结构中，即所谓的集群运行图(Cluster Map )里。集群运行图与RADOS提供的特定算法相配合，便实现了Ceph的许多优秀特性。</p><p><strong>Librados</strong>：Librados库实际上是对RADOS进行抽象和封装，并向上层提供API，支持PHP、Ruby、Java、Python、C和C++编程语言。它为Ceph存储集群（RADOS）提供了本机接口，并为其他服务提供基础，如RBD、RGW和CephFS，这些服务构建在Librados之上，Librados还支持从应用程序直接访问RADOS，没有HTTP开销。</p><p><strong>RBD</strong>：RBD提供了一个标准的块设备接口，常用于在虚拟化的场景下为虚拟机创建存储卷，Red Hat已经将RBD驱动集成在QEMU&#x2F;KVM中，以提高虚拟机的访问性能。</p><p><strong>RADOS GW</strong>：Ceph对象网关RADOS GW提供对象存储服务，是一个构建在Librados库之上的对象存储接口，为应用访问Ceph集群提供了一个与Amazon S3和OpenStack Swift兼容的RESTful风格的 网关。</p><p><strong>Ceph FS</strong>：Ceph文件系统提供了一个符合posix标准的文件系统，它使用Ceph存储集群在文件系统上存储用户数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Ceph 官方定义&lt;/strong&gt;&lt;br&gt;Ceph is a unified, distributed storage system designed for excellent performance, reliability and scalabili</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/Ceph/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>块存储_文件系统存储_对象存储的区别</title>
    <link href="https://watsonlu6.github.io/%E5%9D%97%E5%AD%98%E5%82%A8-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://watsonlu6.github.io/%E5%9D%97%E5%AD%98%E5%82%A8-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-07-13T15:29:15.000Z</published>
    <updated>2024-07-13T15:48:21.670Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/%E5%9D%97%E5%AD%98%E5%82%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p><h2 id="定义角度"><a href="#定义角度" class="headerlink" title="定义角度"></a>定义角度</h2><ul><li><strong>块存储</strong><br>指以扇区为基础，一个或者连续的扇区组成一个块，也叫物理块。它是在文件系统与块设备(例如：磁盘驱动器)之间。利用多个物理硬盘的并发能力。关注的是写入偏移位置。 </li><li><strong>文件系统存储</strong><br>文件系统存储也称为文件级存储或基于文件的存储，数据会以单条信息的形式存储在文件夹中。当需要访问该数据时，计算机需要知道相应的查找路径，存储在文件中的数据会根据数量有限的元数据来进行整理和检索，这些元数据会告诉计算机文件所在的确切位置。它就像是数据文件的库卡目录。</li><li><strong>对象存储</strong><br>对象存储，也称为基于对象的存储，是一种扁平结构，其中的文件被拆分成多个部分并散布在多个硬件间。在对象存储中，数据会被分解为称为“对象”的离散单元，并保存在单个存储库中，而不是作为文件夹中的文件或服务器上的块来保存。</li></ul><h2 id="使用角度"><a href="#使用角度" class="headerlink" title="使用角度"></a>使用角度</h2><ul><li><strong>块存储</strong><br>生活中常见的块存储设备（也叫“块设备”）比如，插在你本地电脑上的U盘、硬盘，你电脑连接的iSCSI等。<br>从使用上来说，块级的存储如果是第一次使用，那么必须需要进行一次格式化的操作，创建出一个文件系统，然后才可以使用。例如新买的U盘、硬盘、或者新发现的iSCSI设备等，首次使用的时候都需要进行一次格式化操作，创建出一个文件系统，然后才可以将你的文件拷贝到U盘、硬盘、或者新发现的iSCSI设备中。</li><li><strong>文件系统存储</strong><br>文件系统存储是最常见的一种文件内系统，我们日常对操作系使用中，基本上能够直接接触到的都就是这种，能够直接访问的C、D、E盘，电脑里的一个目录，网上邻居的空间都是文件级的存储。块级的存储设备经过格式化以及挂载（win 会自动挂载）之后，你就将一个块级的存储变成了文件级的存储。</li><li><strong>对象存储</strong><br>对象存储一般来说并不是给我们人直接去使用的，从使用者角度来说，它更适合用用于给程序使用。平时最常见的一般就是百度网盘，其后端对接的就是对象存储。还有就网页上的图片、视频，其本身也是存储在对象存储的文件系统中的。如果要直接使用对象级的存储，你会发现对象级的存储本身是非常的简单的（但是对人来说不方便），它只有简单的几种命令如上传、下载、删除，并且你只需要知道某个文件的编号（如：”d5t35e6tdud725dgs6u2hdsh27dh27d7”  这不是名字）就可以直接对它进行上传、下载、删除等操作，不需要像文件级那样，直到文件的具体的路径（如:D:\photo\1.jpg），并且他也只有这几种操作，如果你想编辑文件，那只能将文件下载下来编辑好之后在进行上传（这也是它对人来说不方便的原因之一）</li></ul><h2 id="技术角度"><a href="#技术角度" class="headerlink" title="技术角度"></a>技术角度</h2><p>块级、文件级、对象级技术上的区别，首先要明白两个概念<br>第一，无论是那个级别的存储系统，其数据都是会存储在物理的存储设备上的，这些存储设备现在常见的基本上就两种机械硬盘、固态硬盘。<br>第二，任何数据都是由两部”数据“分组成的，一部分是”数据本身”(下文中“数据”指”数据本身“)，另一部分就是这些“数据”的”元数据“。所谓的”元数据”就是用来描述”数据”的”数据”。包括数据所在的位置，文件的长度（大小），文件的访问权限、文件的时间戳（创建时间、修改时间….），元数据本身也是数据。</p><ul><li><strong>块存储</strong><br>对于块级来说，如果要通过块设备来访问一段数据的话，你自己需要知道这些数据具体是存在于那个存储设备上的位置上，例如如果你要从块设备上读取一张照片，你就要高速存储设备：我要从第2块硬盘中的从A位置开始到B位置的数据，硬盘的驱动就会将这个数据给你。读取照片的过程中照片的具体位置就是元数据，也就是说块级的存储中要求程序自己保存元数据。</li><li><strong>文件系统存储</strong><br>如果需要自己保存元数据的话就太麻烦了，上文也说了，元数据本身也是数据，实际上元数据也是存储在硬盘上的，那么如何访问元数据这个数据呢其实，文件级的元数据是存储在固定位置的，存储的位置和方式是大家事先约定好的，这个约定就叫做文件系统，例如EXT4、FAT32、XFS、NTFS等。借助于这些约定，我们就不用自己去维护一个表去记录每一份数据的具体存储位置了。我们只需要直到我们存储的文件的路径和名字就好了，例如我们想要 D:\1.jpg 这个文件，那么你只需要告诉文件系统 D:\1.jpg 这个位置就可以了，去硬盘的哪里找D:\1.jpg 数据的真身，就是文件系统的工作了</li><li><strong>对象存储</strong><br>对象级存储，文件级的元数据实际上是和数据放在一起的，就像一本书每本书都有一个目录，这个目录描述的是这本书上内容的索引，目录就是书内容的“元数据”，而对象存储，会有一本书只放目录（元数据），其他更多的书只有内容，并且内容都是被拆分好的一段一段的，就是说你会看每本书上面的内容完全是混在在一起的，这一页的前两行是书A的某句话，后面就跟的是书D的某句话，如果只放目录（元数据）那本书，你根本不知道这里写的是啥。对象及存储将一切的文件都视作对象，并且将对象按照固定的”形式”组合或拆分的存储在存储设备中，并且将数据的元数据部分完全的独立出来，进行单独的管理。</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li>从<strong>距离（io路径）</strong> 上来说（相对于传统的存储），块存储的使用者距离最底层实际存储数据的存储设备是最近的，对象级是最远的。</li><li>从<strong>使用</strong>上来说，块存储需要使用者自己直到数据的真是位置，需要自己管理记录这些数据，所以使用上是最复杂的，而对象存储的接口最简单，基本上只有上传、下载、删除，并且不需要自己保存元数据，也不需要直到文件的索引路径，所以使用上是最简单的。但是从方便角度来讲还是文件存储最方便。</li><li>从<strong>性能</strong>上来说，综合的来讲（在特定的应用场合）性能最好的是块存储，它主要用在数据库、对延时要求非常高的场景中，对象存储多用于互联网，因为扩展性好，容量可以做的非常的大。对于人类来说，如果不借助特定的客户端、APP，使用文件存储是最友好最简单的。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><strong>块存储：</strong> 要求高性能的应用，如数据库需要高IO，用块存储比较合适。</li><li><strong>文件系统存储：</strong> 需局域网共享的应用，如文件共享，视频处理，动画渲染&#x2F;高性能计算。</li><li><strong>对象存储：</strong> 互联网领域的存储，如点播&#x2F;视频监控的视频存储、图片存储、网盘存储、静态网页存储等，以及异地备份存储&#x2F;归档等。</li></ul><p><img src="/images/%E5%9D%97%E5%AD%98%E5%82%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%8C%BA%E5%88%AB_1.png"></p><h2 id="为什么块级的存储性能最好"><a href="#为什么块级的存储性能最好" class="headerlink" title="为什么块级的存储性能最好"></a>为什么块级的存储性能最好</h2><p>&emsp;&emsp;首先要明确一点，要明确，每次在发生数据读取访问的时候，实际上对应系统的底层是发生了多次IO的（主要是要对元数据进行访问），例如，你要打开文件1.txt ，操作系统回去进行文件是否存在的查询，以及读写权限的查询等操作，这些操作实际上都是对于元数据的访问。<br>&emsp;&emsp;然后，相对于其它的存储方式，块存储的元数据是有操作系统自己管理的，也就是说整个文件系统（元数据）是存在在操做系统的内存中的，这样操作系统在进行元数据管理的时候可以直和自己的内存打交道。而文件系统存储和对象存储，它的文件系统是存在于另一台服务器上的，这样在进行元数据访问时就需要从网络进行访问，这样要比从内存访问慢得多。<br>&emsp;&emsp;总结来讲，就是块级存储的元数据在系统本机中，在进行元数据访问（每次读写文件实际都会在操作系统底层发生），会更快，因为其它的级别的存储元数据都要通过网络访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/%E5%9D%97%E5%AD%98%E5%82%A8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="存储基础" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="存储基础" scheme="https://watsonlu6.github.io/tags/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>云存储概述</title>
    <link href="https://watsonlu6.github.io/%E4%BA%91%E5%AD%98%E5%82%A8%E6%A6%82%E8%BF%B0/"/>
    <id>https://watsonlu6.github.io/%E4%BA%91%E5%AD%98%E5%82%A8%E6%A6%82%E8%BF%B0/</id>
    <published>2024-07-11T15:09:26.000Z</published>
    <updated>2024-07-13T15:53:41.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云存储概述"><a href="#云存储概述" class="headerlink" title="云存储概述"></a>云存储概述</h2><p><img src="/images/%E4%BA%91%E5%AD%98%E5%82%A8%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF.png"></p><h4 id="云存储的概述"><a href="#云存储的概述" class="headerlink" title="云存储的概述"></a>云存储的概述</h4><p>云存储是指通过网络，将分布在不同地方的多种存储设备，通过应用软件集合起来共同对外提供数据存储和业务访问功能的一个系统。云存储是云计算系统中的一种新型网络存储技术。云存储对外提供的存储能力以统一、简单的数据服务接口来提供和展现。用户不用关心数据具体存放在哪个设备、哪个区域，甚至不知道数据到底是怎么保存的，他们只需要关心需要多少存储空间、什么时间能够拿到数据、数据存放的安全性和可用性如何即可。</p><h4 id="云存储的实现模式"><a href="#云存储的实现模式" class="headerlink" title="云存储的实现模式"></a>云存储的实现模式</h4><p>云存储的实现模式有多种，云存储的架构可以由传统的存储架构延伸而来，也可以采用全新的云计算架构。云存储的实现可以是软件的，也可以是硬件的。云存储的实现模式可以是块存储、文件存储和对象存储。</p><ul><li><p><strong>块存储</strong></p><ul><li>块存储：最接近底层的存储，可以对数据进行任意格式化操作，可以在上面运行数据库等性能要求高的应用。可以给虚拟机使用。</li></ul></li><li><p><strong>文件存储</strong></p><ul><li>文件存储：对数据以文件的形式进行存储，支持复杂的文件操作，适合共享文件和协作工作。典型应用场景：NAS。</li></ul></li><li><p><strong>对象存储</strong></p><ul><li>对象存储：将数据以对象形式存储，通过唯一的对象ID进行访问，适合存储大规模非结构化数据，支持RESTful API接口。典型应用场景：云存储服务，视频、图片存储。</li></ul></li></ul><h4 id="为什么需要多元化存储？"><a href="#为什么需要多元化存储？" class="headerlink" title="为什么需要多元化存储？"></a>为什么需要多元化存储？</h4><p>由于不同的应用场景对存储的需求不同，单一的存储类型无法满足所有需求。大规模存储系统需要支持多种存储类型和多种存储协议，比如NFS、iSCSI、HDFS、S3等。多元化存储可以更好地适应各种应用场景，提高存储系统的灵活性和适应性。</p><h4 id="文件如何通过分布式存储在许多服务器中"><a href="#文件如何通过分布式存储在许多服务器中" class="headerlink" title="文件如何通过分布式存储在许多服务器中"></a>文件如何通过分布式存储在许多服务器中</h4><p>分布式存储系统将数据分散存储在多个物理设备上。文件被切分成多个小块，存储在不同的服务器上。通过分布式哈希表（DHT）等算法确定数据块的位置，实现数据的快速定位和访问。通过数据复制和纠删码技术提高数据的可靠性和可用性。</p><h4 id="文件被读取时如何快速找到数据块，确保大目标的组合数据不会丢失？"><a href="#文件被读取时如何快速找到数据块，确保大目标的组合数据不会丢失？" class="headerlink" title="文件被读取时如何快速找到数据块，确保大目标的组合数据不会丢失？"></a>文件被读取时如何快速找到数据块，确保大目标的组合数据不会丢失？</h4><p>元数据服务器（MDS）存储文件系统的元数据，包括文件名、文件大小、数据块位置等信息。客户端请求文件时，首先查询MDS获取元数据，然后根据元数据访问对应的数据块。分布式文件系统中常用的元数据管理技术包括分布式哈希表（DHT）、目录树、名称节点（NameNode）等。</p><h4 id="如果文件丢失怎么办？"><a href="#如果文件丢失怎么办？" class="headerlink" title="如果文件丢失怎么办？"></a>如果文件丢失怎么办？</h4><p>由于分布式存储系统的特性，单一数据副本的丢失不会导致数据不可恢复。分布式存储系统采用数据冗余和副本机制，常见的冗余技术包括数据复制和纠删码。数据复制是将同一份数据存储在多个节点上，副本数通常为3个或更多。纠删码是一种冗余编码技术，通过增加校验数据，在数据块丢失的情况下，可以通过校验数据恢复原始数据。分布式存储系统在后台自动检测数据块的健康状态，发现数据丢失或损坏时，自动启动数据恢复机制，确保数据的完整性和可用性。</p><h4 id="存储系统的数据可靠性（就像RAID）以及可用性（如高可用性）是如何解决的？"><a href="#存储系统的数据可靠性（就像RAID）以及可用性（如高可用性）是如何解决的？" class="headerlink" title="存储系统的数据可靠性（就像RAID）以及可用性（如高可用性）是如何解决的？"></a>存储系统的数据可靠性（就像RAID）以及可用性（如高可用性）是如何解决的？</h4><p>存储系统的数据可靠性和可用性通过多种技术手段来保证。RAID技术通过数据条带化、镜像、奇偶校验等方法，提高单一存储设备的数据可靠性。分布式存储系统通过数据复制和纠删码技术，在多个节点上存储数据副本，提高数据的可靠性和可用性。高可用性通过冗余设计实现，常见的高可用架构包括双机热备、集群等。通过负载均衡技术，将用户请求分散到多个节点上，提高系统的可用性。</p><h4 id="写入的数据是如何被保护的？"><a href="#写入的数据是如何被保护的？" class="headerlink" title="写入的数据是如何被保护的？"></a>写入的数据是如何被保护的？</h4><p>数据写入时，采用多副本机制，确保数据的一致性和可靠性。写时复制（Copy-On-Write，COW）是一种常见的技术，通过在写入数据前复制一份旧数据，确保数据写入过程中的一致性。在分布式存储系统中，数据写入时，通常会先写入多个副本，只有所有副本写入成功后，才算写入成功。数据写入过程中的故障检测和处理机制，确保数据的可靠性和一致性。</p><h4 id="多人多设备协作时，如何保证远程协作时数据的一致性？"><a href="#多人多设备协作时，如何保证远程协作时数据的一致性？" class="headerlink" title="多人多设备协作时，如何保证远程协作时数据的一致性？"></a>多人多设备协作时，如何保证远程协作时数据的一致性？</h4><p>分布式存储系统通过分布式一致性协议（如Paxos、Raft）确保数据的一致性。在多个节点之间进行数据写入时，一致性协议保证数据的一致性和正确性。冲突检测和处理机制，在多人协作时，检测并解决数据冲突。分布式锁和事务机制，确保数据的一致性和完整性。</p><h4 id="节省存储空间"><a href="#节省存储空间" class="headerlink" title="节省存储空间"></a>节省存储空间</h4><p>存储系统采用数据压缩和数据去重技术，减少存储空间占用。数据压缩通过减少数据的冗余，提高存储空间的利用率。数据去重通过检测和删除重复数据，节省存储空间。在大规模存储系统中，数据压缩和去重技术可以显著降低存储成本，提高存储效率。</p><h4 id="避免存储固定的文件"><a href="#避免存储固定的文件" class="headerlink" title="避免存储固定的文件"></a>避免存储固定的文件</h4><p>存储系统采用分级存储和冷热数据分离策略，提高存储资源的利用率。根据数据的访问频率和重要性，将数据存储在不同的存储介质上。频繁访问的数据存储在高速存储设备上，减少访问延迟。较少访问的数据存储在低成本存储设备上，降低存储成本。通过冷热数据分离，优化存储资源的使用，提高存储系统的性能和效率。</p><h4 id="IO速度要有保证"><a href="#IO速度要有保证" class="headerlink" title="IO速度要有保证"></a>IO速度要有保证</h4><p>存储系统通过多种技术手段保证IO速度。使用高速缓存技术，将热点数据缓存到内存或SSD中，减少数据访问延迟。采用预取技术，在数据请求到达前提前加载数据，提高数据访问速度。使用QoS（Quality of Service）技术，为不同的应用场景和用户提供不同的IO优先级和带宽保障。负载均衡技术，将IO请求分散到多个存储节点上，避免单点瓶颈，提高IO性能。</p><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>存储系统提供版本控制功能，允许用户对数据进行版本管理。在数据修改前，保存一份旧版本的数据，用户可以根据需要回滚到旧版本。版本控制功能确保数据的可追溯性和可恢复性，防止数据丢失和误操作。在分布式存储系统中，版本控制功能通过元数据管理和数据快照技术实现。元数据管理记录数据的版本信息和变更历史，数据快照技术保存数据的不同版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;云存储概述&quot;&gt;&lt;a href=&quot;#云存储概述&quot; class=&quot;headerlink&quot; title=&quot;云存储概述&quot;&gt;&lt;/a&gt;云存储概述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/%E4%BA%91%E5%AD%98%E5%82%A8%E5%BA%95%E5%</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="存储基础" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="存储基础" scheme="https://watsonlu6.github.io/tags/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux存储栈</title>
    <link href="https://watsonlu6.github.io/Linux%E5%AD%98%E5%82%A8%E6%A0%88/"/>
    <id>https://watsonlu6.github.io/Linux%E5%AD%98%E5%82%A8%E6%A0%88/</id>
    <published>2024-07-10T12:24:56.000Z</published>
    <updated>2024-07-13T15:50:12.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux存储栈"><a href="#Linux存储栈" class="headerlink" title="Linux存储栈"></a>Linux存储栈</h1><p><img src="/images/linux_storage_stack.png"><br>Linux存储系统包括用户接口和存储设备接口两个部分，前者以流形式处理数据，后者以块形式处理数据，文件系统在中间起到承上启下的作用。应用程序通过系统调用发出写请求，文件系统定位请求位置并转换成块设备所需的块，然后发送到设备上。内存在此过程中作为磁盘缓冲，将上下两部分隔离成异步运行的两个过程，避免频繁的磁盘同步。当数据需要从页面缓存同步到磁盘时，请求被包装成包含多个bio的request，每个bio包含需要同步的数据页。磁盘在执行写操作时，需要通过IO请求调度合理安排顺序，减少磁头的频繁移动，提高磁盘性能。</p><ol><li><h5 id="用户视角的数据流接口"><a href="#用户视角的数据流接口" class="headerlink" title="用户视角的数据流接口"></a>用户视角的数据流接口</h5><p> 应用程序通过系统调用（如<code>write</code>、<code>read</code>等）与操作系统交互。这些调用使得数据以流的形式被处理。</p></li><li><h5 id="存储设备的块接口"><a href="#存储设备的块接口" class="headerlink" title="存储设备的块接口"></a>存储设备的块接口</h5><p> 数据在底层存储设备（如硬盘、SSD等）中以块（通常是512字节或4096字节）为单位进行读写操作。</p></li><li><h5 id="文件系统的中间角色"><a href="#文件系统的中间角色" class="headerlink" title="文件系统的中间角色"></a>文件系统的中间角色</h5><ul><li><strong>位置定位</strong>：文件系统负责将用户的读写请求定位到存储设备的具体块位置。</li><li><strong>数据转换</strong>：将数据流转换为存储设备所需的块结构，并将这些块组织成<code>bio</code>（block I&#x2F;O）请求。</li></ul></li><li><h5 id="内存作为缓冲"><a href="#内存作为缓冲" class="headerlink" title="内存作为缓冲"></a>内存作为缓冲</h5><ul><li><strong>页面缓存</strong>：内存中的页面缓存（Page Cache）用于暂时存储数据，以减少频繁的磁盘I&#x2F;O操作。</li><li><strong>异步运行</strong>：将用户操作与底层存储设备的实际写操作异步化，提升系统效率。对于用户态程序来说，数据尽量保留在内存中，这样可以减少频繁的数据同步。</li></ul></li><li><h5 id="I-O请求调度"><a href="#I-O请求调度" class="headerlink" title="I&#x2F;O请求调度"></a>I&#x2F;O请求调度</h5><ul><li><strong>请求封装</strong>：从页面缓存同步到磁盘的请求被封装成<code>request</code>，每个<code>request</code>包含多个<code>bio</code>，而每个<code>bio</code>又包含具体的数据页。</li><li><strong>调度策略</strong>：操作系统会对I&#x2F;O请求进行调度，优化执行顺序，尽量减少磁盘磁头的来回移动，提高磁盘的读写效率。</li></ul></li></ol><h5 id="Linux数据写入流程"><a href="#Linux数据写入流程" class="headerlink" title="Linux数据写入流程"></a>Linux数据写入流程</h5><ol><li><strong>应用程序发出写请求</strong>：比如，应用程序通过<code>write</code>系统调用写入数据。</li><li><strong>文件系统处理</strong>：文件系统接收请求，找到对应的文件位置，将数据写入页面缓存。</li><li><strong>内存缓冲处理</strong>：数据暂存在内存的页面缓存中，以等待后续的写入操作。</li><li><strong>请求调度与封装</strong>：页面缓存的数据需要同步到磁盘时，被封装成<code>bio</code>和<code>request</code>。</li><li><strong>I&#x2F;O调度执行</strong>：调度器优化I&#x2F;O请求的执行顺序，减少磁头移动，提高写入效率。</li><li><strong>数据写入磁盘</strong>：最终，数据从页面缓存同步到磁盘的指定位置，完成写操作。<br>通过以上流程，Linux存储系统在保证数据一致性的同时，最大限度地提高了性能和效率。</li></ol><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><img src="/images/linux_storage_stack_1.png"><br>&emsp;&emsp;用户应用程序访问并使用内核所提供的各种服务的途径即是系统调用。在内核和应用程序交叉的地方，内核提供了一组系统调用接口，通过这组接口，应用程序可以访问系统硬件和各种操作系统资源。用户可以通过文件系统相关的调用请求系统打开问价、关闭文件和读写文件。<br>&emsp;&emsp;内核提供的这组系统调用称为系统调用接口层。系统调用接口把应用程序的请求传达给内核，待内核处理完请求后再将处理结果返回给应用程序。<br>&emsp;&emsp;32位Linux，CPU能访问4GB的虚拟空间，其中低3GB的地址是应用层的地址空间，高地址的1GB是留给内核使用的。内核中所有线程共享这1GB的地址空间，而每个进程可以有自己的独立的3GB的虚拟空间，互不干扰。<br>&emsp;&emsp;当一个进程运行的时候，其用到文件的代码段，数据段等都是映射到内存地址区域的，这个功能是通过系统调用mmap()来完成的。mmap()将文件（由文件句柄fd所指定）从偏移offset的位置开始的长度为length的一个块映射到内存区域中，从而把文件的某一段映射到进程的地址空间，这样程序就可以通过访问内存的方式访问文件了。与read()&#x2F;write()相比，使用mmap的方式对文件进行访问，带来的一个显著好处就是可以减少一次用户空间到内核空间的复制，在某些场景下，如音频、视频等大文件，可以带来性能的提升。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p><img src="/images/linux_storage_stack_2.png"><br>&emsp;&emsp;Linux文件系统的体系结构是一个对复杂系统进行抽象化，通过使用一组通用的API函数，Linux就可以在多种存储设备上支持多种文件系统，使得它拥有了与其他操作系统和谐共存的能力。<br>&emsp;&emsp;Linux中文件的概念并不局限于普通的磁盘文件，而是由字节序列构成的信息载体，I&#x2F;O设备、socket等也被包括在内。因为有了文件的存在，所以需要衍生文件系统去进行组织和管理文件，而为了支持各种各样的文件系统，所以有了虚拟文件系统的出现。文件系统是一种对存储设备上的文件、数据进行存储和组织的机制。<br>&emsp;&emsp;虚拟文件系统通过在各种具体的文件系统上建立了一个抽象层，屏蔽了不同文件系统间的差异，通过虚拟文件系统分层架构，在对文件进行操作时，便不需要去关心相关文件所在的具体文件系统细节。通过系统调用层，可以在不同文件系统之间复制和移动数据，正是虚拟文件系统使得这种跨越不同存储设备和不同文件系统的操作成为了可能。</p><h4 id="虚拟文件系统象类型"><a href="#虚拟文件系统象类型" class="headerlink" title="虚拟文件系统象类型"></a>虚拟文件系统象类型</h4><ul><li><strong>超级块（Super Block）</strong><br>超级块对象代表了一个已经安装的文件系统，用于存储该文件系统的相关信息，如文件系统的类型、大小、状态等。对基于磁盘的文件系统， 这类对象通常存放在磁盘特定的扇区上。对于并非基于磁盘的文件系统，它们会现场创建超级块对象并将其保存在内存中。</li><li><strong>索引节点（Inode）</strong><br>索引节点对象代表存储设备上的一个实际物理文件，用于存储该文件的有关信息。Linux将文件的相关信息（如访问权限、大小、创建时间等）与文件本身区分开。文件的相关信息又被称为文件的元数据。</li><li><strong>目录项（Dentry)</strong><br>  目录项对象描述了文件系统的层次结构，一个路径的各个组成部分，不管是目录（虚拟文件系统将目录当作文件来处理）还是普通文件，都是一个目录项对象。</li><li><strong>文件</strong><br>  文件对象代表已经被进程打开的文件，主要用于建立进程和文件之间的对应关系。它由open()系统调用创建，由close()系统调用销毁，当且仅当进程访问文件期间存在于内存中，同一个物理文件可能存在多个对应的文件对象，但其对应的索引节点对象是唯一的。</li></ul><h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><p><img src="/images/linux_storage_stack_3.png"><br>&emsp;&emsp;Page Cache，通常也称为文件缓存，使用内存Page Cache文件的逻辑内容，从而提高对磁盘文件的访问速度。Page Cache是以物理页为单位对磁盘文件进行缓存的。<br>&emsp;&emsp;应用程序尝试读取某块数据的时候，会首先查找Page Cache，如果这块数据已经存放在Page Cache中，那么就可以立即返回给应用程序，而不需要再进行实际的物理磁盘操作。如果不能在Page Cache中发现要读取的数据，那么就需要先将数据从磁盘读取到Page Cache中，同样，对于写操作来说，应用程序也会将数据写到Page Cache中，再根据所采用的写操作机制，判断数据是否应该立即被写到磁盘上</p><h2 id="Direct-I-O和Buffered-I-O"><a href="#Direct-I-O和Buffered-I-O" class="headerlink" title="Direct I&#x2F;O和Buffered I&#x2F;O"></a>Direct I&#x2F;O和Buffered I&#x2F;O</h2><p><img src="/images/linux_storage_stack_4.png"><br>进程产生的IO路径主要有Direct I&#x2F;O和Buffered I&#x2F;O两条</p><ul><li><strong>标准I&#x2F;O：</strong> 也称为Buffered I&#x2F;O；Linux会将I&#x2F;O的数据缓存在Page Cache中，也就是说，数据会先被复制到内核的缓冲区，再从内核的缓冲区复制到应用程序的用户地址空间。在Buffered I&#x2F;O机制中，在没有CPU干预的情况下，可以通过DMA操作在磁盘和Page Cache之间直接进行数据的传输，在一定程度上分离了应用程序和物理设备，但是没有方法能直接在应用程序的地址空间和磁盘之间进行数据传输，数据在传输过程中需要在用户空间和Page Cache之间进行多次数据复制操作，这将带来较大的CPU开销。</li><li><strong>Direct I&#x2F;O：</strong> 可以省略使用Buffered I&#x2F;O中的内核缓冲区，数据可以直接在用户空间和磁盘之间进行传输，从而使得缓存应用程序可以避开复杂系统级别的缓存结构，执行自定义的数据读写管理，从而降低系统级别的管理对应用程序访问数据的影响。如果在块设备中执行Direct I&#x2F;O，那么进程必须在打开文件的时候将对文件的访问模式设置为O_DIRECT，这样就等于告诉Linux进程在接下来将使用Direct I&#x2F;O方式去读写文件，且传输的数据不经过内核中的Page Cache。Direct I&#x2F;O最主要的优点就是通过减少内核缓冲区和用户空间的数据复制次数，降低文件读写时所带来的CPU负载能力及内存带宽的占用率。如果传输的数据量很大，使用Direct IO的方式将会大大提高性能。然而，不经过内湖缓冲区直接进行磁盘的读写，必然会引起阻塞，因此通常Direct IO和AIO（异步IO）一起使用。</li></ul><h2 id="块层（Block-Layer）"><a href="#块层（Block-Layer）" class="headerlink" title="块层（Block Layer）"></a>块层（Block Layer）</h2><p><img src="/images/linux_storage_stack_5.png"><br>&emsp;&emsp;块设备访问时，需要在介质的不同区间前后移动，对于内核来说，管理块设备要比管理字符设备复杂得多。<br>&emsp;&emsp;系统调用read()触发相应的虚拟文件系统函数，虚拟文件系统判断请求是否已经在内核缓冲区里，如果不在，则判断如何执行读操作。如果内核必须从块设备上读取数据，就必须要确定数据在物理设备上的位置。这由映射层，即磁盘文件系统来完成。文件系统将文件访问映射为设备访问。<br>在通用块层中，使用bio结构体来描述一个I&#x2F;O请求在上层文件系统与底层物理磁盘之间的关系。而到了Linux驱动，则是使用request结构体来描述向块设备发出的I&#x2F;O请求的。对于慢速的磁盘而言，请求的处理速度很慢，这是内核就提供一种队列的机制把这些I&#x2F;O请求添加到队列中，使用request_queue结构体来描述。<br>&emsp;&emsp;bio和request是块层最核心的两个数据结构，其中，bio描述了磁盘里要真实操作的位置和Page Cache中的映射关系。作为Linux I&#x2F;O请求的基本单元，bio结构贯穿块层对I&#x2F;O请求处理的始终，每个bio对应磁盘里面一块连续的位置，bio结构中的bio_vec是一个bio的数据容器，专门用来保存bio的数据，包含一块数据所在页，以及页内的偏移及长度信息，通过这些信息就可以很清晰地描述数据具体什么位置。request用来描述单次I&#x2F;O请求，request_queue用来描述与设备相关的请求队列，每个块设备在块层都有一个request_queue与之对应，所有对该块设备的I&#x2F;O请求最后都会流经request_queue。块层正是借助bio、bio_vec、request、request_queue这几个结构将I&#x2F;O请求在内核I&#x2F;O子系统各个层次的处理过程联系起来。</p><ul><li><strong>I&#x2F;O调度算法：</strong> noop算法（不调度算法）、deadline算法（改良的电梯算法）、CFQ算法（完全公平调度算法，对于通用的服务器来说，CFQ是较好的选择，从Linux2.6.18版本开始，CFQ成为了默认的IO调度算法）。</li><li><strong>I&#x2F;O合并：</strong> 将符合条件的多个IO请求合并成单个IO请求进行一并处理，从而提升IO请求的效率。进程产生的IO路径主要有Direct I&#x2F;O和Buffered I&#x2F;O两条，无论哪一条路径，在bio结构转换为request结构进行IO调度前都需要进入Plug队列进行蓄流（部分Direct IO产生的请求不需要经过蓄流），所以对IO请求来说，能够进行合并的位置主要有Page Cache、Plug List、IO调度器3个。而在块层中，Plug将块层的IO请求聚集起来，使得零散的请求有机会进行合并和排序，最终达到高效利用存储设备的目的。每个进程都有一个私有的Plug队列，进程在向通用块层派发IO派发请求之前如果开始蓄流的功能，那么IO请求在被发送给IO调度器之前都被保存在Plug队列中，直到泄流的时候才被批量交给调度器。蓄流主要是为了增加请求合并的机会，bio在进入Plug队列之前会尝试与Plug队列保存的request进行合并。当应用需要发多个bio请求的时候，比较好的办法是先蓄流，而不是一个个单独发给最终的硬盘。</li></ul><h2 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h2><p>&emsp;&emsp;LVM，即Logical Volume Manager，逻辑卷管理器，是一种硬盘的虚拟化技术，可以允许用户的硬盘资源进行灵活的调整和动态管理。<br>&emsp;&emsp;LVM是Linux系统对于硬盘分区管理的一种机制，诞生是为了解决硬盘设备在创建分区后不易修改分区大小的缺陷。尽管对硬盘的强制性扩容和缩容理论上是可行的，但是却可能造成数据丢失。LVM技术是通过在硬盘分区和文件系统之间增加一个逻辑层，提供了一个抽象的卷组，就可以把多块硬盘设备、硬盘分区，甚至RAID整体进行卷则合并。并可以根据情况进行逻辑上的虚拟分割，这样一来，用户不用关心物理硬盘设备的底层架构和布局，就可以实现对硬盘分区设备的动态调整。<br>&emsp;&emsp;LVM通过在操作系统与物理存储资源之间引入逻辑卷（Logical Volume）的抽象，来解决传统磁盘分区管理工具的问题。LVM将众多不同的物理存储器资源（物理卷，Physical Volume）组成卷组（Volume Group），该卷组可以理解为普通系统的物理磁盘，但是卷组上不能创建或者安装文件系统，而是需要LVM先在卷组中创建一个逻辑卷，然后将ext3等文件系统安装在这个逻辑卷上，可以在不重新引导系统的前提下通过在卷组划分额外的空间，来为这个逻辑卷动态扩容。<br>LVM的架构体系中，有三个很重要的概念：</p><ul><li>PV，物理卷，即实际存在的硬盘、分区或者RAID</li><li>VG，卷组，是由多个物理卷组合形成的大的整体的卷组</li><li>LV，逻辑卷，是从卷组上分割出来的，可以使用使用的逻辑存储设备</li></ul><h2 id="条带化"><a href="#条带化" class="headerlink" title="条带化"></a>条带化</h2><p>&emsp;&emsp;大多数磁盘系统都对访问次数（每秒的 I&#x2F;O 操作，IOPS）和数据传输率（每秒传输的数据量，TPS）有限制。当达到这些限制时，后面需要访问磁盘的进程就需要等待，这时就是所谓的磁盘冲突。避免磁盘冲突是优化 I&#x2F;O 性能的一个重要目标，而 I&#x2F;O 性能的优化与其他资源（如CPU和内存）的优化有着很大的区别 ,I&#x2F;O 优化最有效的手段是将 I&#x2F;O 最大限度的进行平衡。条带化技术就是一种自动的将 I&#x2F;O 的负载均衡到多个物理磁盘上的技术，条带化技术就是将一块连续的数据分成很多小部分并把他们分别存储到不同磁盘上去。这就能使多个进程同时访问数据的多个不同部分而不会造成磁盘冲突，而且在需要对这种数据进行顺序访问的时候可以获得最大程度上的 I&#x2F;O 并行能力，从而获得非常好的性能。很多操作系统、磁盘设备供应商、各种第三方软件都能做到条带化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux存储栈&quot;&gt;&lt;a href=&quot;#Linux存储栈&quot; class=&quot;headerlink&quot; title=&quot;Linux存储栈&quot;&gt;&lt;/a&gt;Linux存储栈&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/linux_storage_stack.png&quot;&gt;&lt;br</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="存储基础" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="存储基础" scheme="https://watsonlu6.github.io/tags/%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Ceph相关数据结构</title>
    <link href="https://watsonlu6.github.io/Ceph%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://watsonlu6.github.io/Ceph%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-07-26T15:33:02.000Z</published>
    <updated>2024-07-26T16:21:44.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ceph-相关数据结构"><a href="#Ceph-相关数据结构" class="headerlink" title="Ceph 相关数据结构"></a>Ceph 相关数据结构</h2><p>要想深入到Ceph的源码底层，就必须对代码通用库里的一些关键，常见的数据结构进行学习，这样才能更好的理解源代码。从最高的逻辑层次为<code>Pool</code>的概念，然后是<code>PG</code>的概念。其次是<code>OSDＭap</code>记录了集群的所有的配置信息。数据结构<code>OSDOp</code>是一个操作上下文的封装。结构<code>object_info_t</code>保存了一个元数据信息和访问信息。对象<code>ObjectState</code>是在<code>object_info_t</code>基础上添加了一些内存的状态信息。<code>SnapSetContext</code>和<code>ObjectContext</code>分别保存了快照和对象上下文相关的信息。<code>Session</code>保存了一个端到端的链接相关的上下文。</p><h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p><code>Pool</code>是整个集群层面定义的一个逻辑的存储池。对一个Pool可以设置相应的数据冗余类型，目前有副本和纠删码两种实现。数据结构pg_pool_t用于保存Pool的相关信息。<br>Pool的数据结构如下：（src&#x2F;osd&#x2F;osd_types.h）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pg_pool_t</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *APPLICATION_NAME_CEPHFS;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *APPLICATION_NAME_RBD;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *APPLICATION_NAME_RGW;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    TYPE_REPLICATED = <span class="number">1</span>,     <span class="comment">// replication  副本   </span></span><br><span class="line">    <span class="comment">//TYPE_RAID4 = 2,   // raid4 (never implemented)   从来没实现的raid4</span></span><br><span class="line">    TYPE_ERASURE = <span class="number">3</span>,      <span class="comment">// erasure-coded   纠删码</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    FLAG_HASHPSPOOL = <span class="number">1</span>&lt;&lt;<span class="number">0</span>, <span class="comment">// hash pg seed and pool together (instead of adding)</span></span><br><span class="line">    FLAG_FULL       = <span class="number">1</span>&lt;&lt;<span class="number">1</span>, <span class="comment">// pool is full</span></span><br><span class="line">    FLAG_EC_OVERWRITES = <span class="number">1</span>&lt;&lt;<span class="number">2</span>, <span class="comment">// enables overwrites, once enabled, cannot be disabled</span></span><br><span class="line">    FLAG_INCOMPLETE_CLONES = <span class="number">1</span>&lt;&lt;<span class="number">3</span>, <span class="comment">// may have incomplete clones (bc we are/were an overlay)</span></span><br><span class="line">    FLAG_NODELETE = <span class="number">1</span>&lt;&lt;<span class="number">4</span>, <span class="comment">// pool can&#x27;t be deleted</span></span><br><span class="line">    FLAG_NOPGCHANGE = <span class="number">1</span>&lt;&lt;<span class="number">5</span>, <span class="comment">// pool&#x27;s pg and pgp num can&#x27;t be changed</span></span><br><span class="line">    FLAG_NOSIZECHANGE = <span class="number">1</span>&lt;&lt;<span class="number">6</span>, <span class="comment">// pool&#x27;s size and min size can&#x27;t be changed</span></span><br><span class="line">    FLAG_WRITE_FADVISE_DONTNEED = <span class="number">1</span>&lt;&lt;<span class="number">7</span>, <span class="comment">// write mode with LIBRADOS_OP_FLAG_FADVISE_DONTNEED</span></span><br><span class="line">    FLAG_NOSCRUB = <span class="number">1</span>&lt;&lt;<span class="number">8</span>, <span class="comment">// block periodic scrub</span></span><br><span class="line">    FLAG_NODEEP_SCRUB = <span class="number">1</span>&lt;&lt;<span class="number">9</span>, <span class="comment">// block periodic deep-scrub</span></span><br><span class="line">    FLAG_FULL_QUOTA = <span class="number">1</span>&lt;&lt;<span class="number">10</span>, <span class="comment">// pool is currently running out of quota, will set FLAG_FULL too</span></span><br><span class="line">    FLAG_NEARFULL = <span class="number">1</span>&lt;&lt;<span class="number">11</span>, <span class="comment">// pool is nearfull</span></span><br><span class="line">    FLAG_BACKFILLFULL = <span class="number">1</span>&lt;&lt;<span class="number">12</span>, <span class="comment">// pool is backfillfull</span></span><br><span class="line">    FLAG_SELFMANAGED_SNAPS = <span class="number">1</span>&lt;&lt;<span class="number">13</span>, <span class="comment">// pool uses selfmanaged snaps</span></span><br><span class="line">    FLAG_POOL_SNAPS = <span class="number">1</span>&lt;&lt;<span class="number">14</span>,        <span class="comment">// pool has pool snaps</span></span><br><span class="line">    FLAG_CREATING = <span class="number">1</span>&lt;&lt;<span class="number">15</span>,          <span class="comment">// initial pool PGs are being created</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">utime_t</span> create_time;      <span class="comment">//Pool创建时间</span></span><br><span class="line">  <span class="type">uint64_t</span> flags;           <span class="comment">///&lt; FLAG_*   Pool的相关标志</span></span><br><span class="line">  __u8 type;                <span class="comment">///&lt; TYPE_*   类型</span></span><br><span class="line">  __u8 size, min_size;     <span class="comment">///&lt;Pool的size和min_size，即副本数和至少保证的副本数</span></span><br><span class="line">  __u8 crush_rule;          <span class="comment">///&lt; crush placement rule    rule的编号</span></span><br><span class="line">  __u8 object_hash;         <span class="comment">///&lt; hash mapping object name to ps   对象映射的hash函数</span></span><br><span class="line">  __u8 pg_autoscale_mode;   <span class="comment">///&lt; PG_AUTOSCALE_MODE_        PG数自动增减模式</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  __u32 pg_num = <span class="number">0</span>, pgp_num = <span class="number">0</span>;  <span class="comment">///&lt; pg、pgp的数量</span></span><br><span class="line">  __u32 pg_num_pending = <span class="number">0</span>;       <span class="comment">///&lt; pg_num we are about to merge down to</span></span><br><span class="line">  __u32 pg_num_target = <span class="number">0</span>;        <span class="comment">///&lt; pg_num we should converge toward</span></span><br><span class="line">  __u32 pgp_num_target = <span class="number">0</span>;       <span class="comment">///&lt; pgp_num we should converge toward</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  map&lt;string,string&gt; properties;  <span class="comment">///&lt; OBSOLETE</span></span><br><span class="line">  string erasure_code_profile; <span class="comment">///&lt; name of the erasure code profile in OSDMap</span></span><br><span class="line">  <span class="type">epoch_t</span> last_change;      <span class="comment">///&lt; most recent epoch changed, exclusing snapshot changes</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// last epoch that forced clients to resend</span></span><br><span class="line">  <span class="type">epoch_t</span> last_force_op_resend = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/// last epoch that forced clients to resend (pre-nautilus clients only)</span></span><br><span class="line">  <span class="type">epoch_t</span> last_force_op_resend_prenautilus = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/// last epoch that forced clients to resend (pre-luminous clients only)</span></span><br><span class="line">  <span class="type">epoch_t</span> last_force_op_resend_preluminous = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// metadata for the most recent PG merge</span></span><br><span class="line">  <span class="type">pg_merge_meta_t</span> last_pg_merge_meta;</span><br><span class="line">  </span><br><span class="line">  <span class="type">snapid_t</span> snap_seq;        <span class="comment">///&lt; seq for per-pool snapshot</span></span><br><span class="line">  <span class="type">epoch_t</span> snap_epoch;       <span class="comment">///&lt; osdmap epoch of last snap</span></span><br><span class="line">  <span class="type">uint64_t</span> auid;            <span class="comment">///&lt; who owns the pg</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> quota_max_bytes; <span class="comment">///&lt; maximum number of bytes for this pool</span></span><br><span class="line">  <span class="type">uint64_t</span> quota_max_objects; <span class="comment">///&lt; maximum number of objects for this pool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Pool snaps (global to this pool).  These define a SnapContext for</span></span><br><span class="line"><span class="comment">   * the pool, unless the client manually specifies an alternate</span></span><br><span class="line"><span class="comment">   * context.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  map&lt;<span class="type">snapid_t</span>, <span class="type">pool_snap_info_t</span>&gt; snaps;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Alternatively, if we are defining non-pool snaps (e.g. via the</span></span><br><span class="line"><span class="comment">   * Ceph MDS), we must track @removed_snaps (since @snaps is not</span></span><br><span class="line"><span class="comment">   * used).  Snaps and removed_snaps are to be used exclusive of each</span></span><br><span class="line"><span class="comment">   * other!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  interval_set&lt;<span class="type">snapid_t</span>&gt; removed_snaps;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> pg_num_mask, pgp_num_mask;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tier cache : Base Storage = N : 1</span></span><br><span class="line">  <span class="comment">// ceph osd tier add &#123;data_pool&#125; &#123;cache pool&#125;</span></span><br><span class="line">  set&lt;<span class="type">uint64_t</span>&gt; tiers;      <span class="comment">///&lt; pools that are tiers of us</span></span><br><span class="line">  <span class="type">int64_t</span> tier_of;         <span class="comment">///&lt; pool for which we are a tier</span></span><br><span class="line">  <span class="comment">// Note that write wins for read+write ops</span></span><br><span class="line">  <span class="comment">// WriteBack mode, read_tier is same as write_tier. Both are cache pool.</span></span><br><span class="line">  <span class="comment">// Diret mode. cache pool is read_tier, not write_tier. </span></span><br><span class="line">  <span class="comment">// ceph osd tier set-overlay &#123;data_pool&#125; &#123;cache_pool&#125;</span></span><br><span class="line">  <span class="type">int64_t</span> read_tier;       <span class="comment">///&lt; pool/tier for objecter to direct reads to</span></span><br><span class="line">  <span class="type">int64_t</span> write_tier;      <span class="comment">///&lt; pool/tier for objecter to direct writes to</span></span><br><span class="line">  <span class="comment">// Set cache mode</span></span><br><span class="line">  <span class="comment">// ceph osd tier cache-mode &#123;cache-pool&#125; &#123;cache-mode&#125;</span></span><br><span class="line">  <span class="type">cache_mode_t</span> cache_mode;  <span class="comment">///&lt; cache pool mode</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> target_max_bytes;   <span class="comment">///&lt; tiering: target max pool size</span></span><br><span class="line">  <span class="type">uint64_t</span> target_max_objects; <span class="comment">///&lt; tiering: target max pool size</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 目标脏数据率：当脏数据比例达到这个值，后台 agent 开始 flush 数据</span></span><br><span class="line">  <span class="type">uint32_t</span> cache_target_dirty_ratio_micro; <span class="comment">///&lt; cache: fraction of target to leave dirty</span></span><br><span class="line">  <span class="comment">// 高目标脏数据率：当脏数据比例达到这个值，后台 agent 开始高速 flush 数据</span></span><br><span class="line">  <span class="type">uint32_t</span> cache_target_dirty_high_ratio_micro; <span class="comment">///&lt; cache: fraction of  target to flush with high speed</span></span><br><span class="line">  <span class="comment">// 数据满的比率：当数据达到这个比例时，认为数据已满，需要进行缓存淘汰</span></span><br><span class="line">  <span class="type">uint32_t</span> cache_target_full_ratio_micro;  <span class="comment">///&lt; cache: fraction of target to fill before we evict in earnest</span></span><br><span class="line">  <span class="comment">// 对象在 cache 中被刷入到 storage 层的最小时间</span></span><br><span class="line">  <span class="type">uint32_t</span> cache_min_flush_age;  <span class="comment">///&lt; minimum age (seconds) before we can flush</span></span><br><span class="line">  <span class="comment">// 对象在 cache 中被淘汰的最小时间</span></span><br><span class="line">  <span class="type">uint32_t</span> cache_min_evict_age;  <span class="comment">///&lt; minimum age (seconds) before we can evict</span></span><br><span class="line">  <span class="comment">// HitSet 相关参数</span></span><br><span class="line">  HitSet::Params hit_set_params; <span class="comment">///&lt; The HitSet params to use on this pool</span></span><br><span class="line">  <span class="comment">// 每间隔 hit_set_period 一段时间，系统重新产生一个新的 hit_set 对象来记录对象的h缓存统计信息</span></span><br><span class="line">  <span class="type">uint32_t</span> hit_set_period;      <span class="comment">///&lt; periodicity of HitSet segments (seconds)</span></span><br><span class="line">  <span class="comment">// 记录系统保存最近的多少个 hit_set 记录</span></span><br><span class="line">  <span class="type">uint32_t</span> hit_set_count;       <span class="comment">///&lt; number of periods to retain</span></span><br><span class="line">  <span class="comment">// hitset archive 对象的命名规则 </span></span><br><span class="line">  <span class="type">bool</span> use_gmt_hitset;        <span class="comment">///&lt; use gmt to name the hitset archive object</span></span><br><span class="line">  <span class="type">uint32_t</span> min_read_recency_for_promote;   <span class="comment">///&lt; minimum number of HitSet to check before promote on read</span></span><br><span class="line">  <span class="type">uint32_t</span> min_write_recency_for_promote;  <span class="comment">///&lt; minimum number of HitSet to check before promote on write</span></span><br><span class="line">  <span class="type">uint32_t</span> hit_set_grade_decay_rate;   <span class="comment">///&lt; current hit_set has highest priority on objects</span></span><br><span class="line">                                       <span class="comment">///&lt; temperature count,the follow hit_set&#x27;s priority decay </span></span><br><span class="line">                                       <span class="comment">///&lt; by this params than pre hit_set</span></span><br><span class="line">                                       <span class="comment">//当前hit_set在对象温度计数上具有最高优先级，后续hit_set的优先级比预hit_set衰减此参数</span></span><br><span class="line">  <span class="type">uint32_t</span> hit_set_search_last_n;   <span class="comment">///&lt; accumulate atmost N hit_sets for temperature  为温度累积最多N次hit_sets</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> stripe_width;        <span class="comment">///&lt; erasure coded stripe size in bytes</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> expected_num_objects; <span class="comment">///&lt; expected number of objects on this pool, a value of 0 indicates</span></span><br><span class="line">                                 <span class="comment">///&lt; user does not specify any expected value</span></span><br><span class="line">  <span class="type">bool</span> fast_read;            <span class="comment">///&lt; whether turn on fast read on the pool or not</span></span><br><span class="line">  <span class="type">pool_opts_t</span> opts; <span class="comment">///&lt; options</span></span><br><span class="line">  <span class="comment">/// application -&gt; key/value metadata</span></span><br><span class="line">  map&lt;string, std::map&lt;string, string&gt;&gt; application_metadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="type">uint32_t</span>&gt; grade_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">get_grade</span><span class="params">(<span class="type">unsigned</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grade_table.<span class="built_in">size</span>() &lt;= i)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> grade_table[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">calc_grade_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> v = <span class="number">1000000</span>;</span><br><span class="line">    grade_table.<span class="built_in">resize</span>(hit_set_count);        <span class="comment">// hit_set_count记录系统保存最近的多少个 hit_set 记录</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; hit_set_count; i++) &#123;</span><br><span class="line">      v = v * (<span class="number">1</span> - (hit_set_grade_decay_rate / <span class="number">100.0</span>));</span><br><span class="line">      grade_table[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数据结构pg_pool_t的成员变量和方法较多，不一一介绍了。</p><h2 id="PG"><a href="#PG" class="headerlink" title="PG"></a>PG</h2><p><code>PG</code>可以认为是一组对象的集合，该集合里的对象有共同特征：副本都分布在相同的OSD列表中。结构体pg_t只是一个PG的静态描述信息（只有三个成员变量），类PG及其子类ReplicatedPG都是和PG相关的处理。<br>pg_t的数据结构如下：（src&#x2F;osd&#x2F;osd_types.h）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pg_t</span> &#123;</span><br><span class="line">  <span class="type">uint64_t</span> m_pool;    <span class="comment">//pg所在的pool</span></span><br><span class="line">  <span class="type">uint32_t</span> m_seed;    <span class="comment">//pg的序号</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> calc_name_buf_size = <span class="number">36</span>;  <span class="comment">// max length for max values len(&quot;18446744073709551615.ffffffff&quot;) + future suffix len(&quot;_head&quot;) + &#x27;\0&#x27;</span></span><br><span class="line">  <span class="function"><span class="type">hobject_t</span> <span class="title">get_hobj_start</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">hobject_t</span> <span class="title">get_hobj_end</span><span class="params">(<span class="type">unsigned</span> pg_num)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">generate_test_instances</span><span class="params">(list&lt;<span class="type">pg_t</span>*&gt;&amp; o)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OSDMap"><a href="#OSDMap" class="headerlink" title="OSDMap"></a>OSDMap</h2><p><code>OSDMap类</code>定义了Ceph整个集群的全局信息。它由Monitor实现管理，并以全量或者增量的方式向整个集群扩散。每一个epoch对应的OSDMap都需要持久化保存在meta下对应对象的omap属性中。内部类Incremental以增量的形式保存了OSDMap新增的信息。OSDMap包含了四类信息：首先是集群的信息，其次是pool的信息，然后是临时PG相关信息，最后就是所有OSD的状态信息。<br>OSDMap类的数据结构如下：（src&#x2F;osd&#x2F;OSDMap.h）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OSDMap</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MEMPOOL_CLASS_HELPERS</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> interval_set&lt;</span><br><span class="line">    <span class="type">snapid_t</span>,</span><br><span class="line">    mempool::osdmap::flat_map&lt;<span class="type">snapid_t</span>,<span class="type">snapid_t</span>&gt;&gt; <span class="type">snap_interval_set_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Incremental</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MEMPOOL_CLASS_HELPERS</span>();</span><br><span class="line"><span class="comment">//系统相关的信息</span></span><br><span class="line">    <span class="comment">/// feature bits we were encoded with.  the subsequent OSDMap</span></span><br><span class="line">    <span class="comment">/// encoding should match.</span></span><br><span class="line">    <span class="type">uint64_t</span> encode_features;</span><br><span class="line">    uuid_d fsid;    <span class="comment">//当前集群的fsid值</span></span><br><span class="line">    <span class="type">epoch_t</span> epoch; <span class="comment">//当前集群的epoch值 new epoch; we are a diff from epoch-1 to epoch</span></span><br><span class="line">    <span class="type">utime_t</span> modified;   <span class="comment">//创建修改的时间戳</span></span><br><span class="line">    <span class="type">int64_t</span> new_pool_max; <span class="comment">//incremented by the OSDMonitor on each pool create</span></span><br><span class="line">    <span class="type">int32_t</span> new_flags;</span><br><span class="line">    <span class="type">int8_t</span> new_require_osd_release = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// full (rare)</span></span><br><span class="line">    bufferlist fullmap;  <span class="comment">// in lieu of below.</span></span><br><span class="line">    bufferlist crush;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">//集群相关的信息</span></span><br><span class="line">  uuid_d fsid;     <span class="comment">//当前集群的fsid值</span></span><br><span class="line">  <span class="type">epoch_t</span> epoch;        <span class="comment">//当前集群的epoch值 what epoch of the osd cluster descriptor is this</span></span><br><span class="line">  <span class="type">utime_t</span> created, modified; <span class="comment">//创建、修改的时间戳 epoch start time   </span></span><br><span class="line">  <span class="type">int32_t</span> pool_max;     <span class="comment">//最大的pool数量 the largest pool num, ever</span></span><br><span class="line">  <span class="type">uint32_t</span> flags;       <span class="comment">//一些标志信息</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//OSD相关的信息</span></span><br><span class="line">  <span class="type">int</span> num_osd;         <span class="comment">//OSD的总数量 not saved; see calc_num_osds</span></span><br><span class="line">  <span class="type">int</span> num_up_osd;      <span class="comment">//处于up状态的OSD的数量 not saved; see calc_num_osds</span></span><br><span class="line">  <span class="type">int</span> num_in_osd;      <span class="comment">//处于in状态的OSD的数量 not saved; see calc_num_osds</span></span><br><span class="line">  <span class="type">int32_t</span> max_osd;     <span class="comment">//OSD的最大数目</span></span><br><span class="line">  vector&lt;<span class="type">uint32_t</span>&gt; osd_state;      <span class="comment">//OSD的状态</span></span><br><span class="line">  mempool::osdmap::map&lt;<span class="type">int32_t</span>,<span class="type">uint32_t</span>&gt; crush_node_flags; <span class="comment">// crush node -&gt; CEPH_OSD_* flags</span></span><br><span class="line">  mempool::osdmap::map&lt;<span class="type">int32_t</span>,<span class="type">uint32_t</span>&gt; device_class_flags; <span class="comment">// device class -&gt; CEPH_OSD_* flags</span></span><br><span class="line"></span><br><span class="line">  <span class="type">utime_t</span> last_up_change, last_in_change;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These features affect OSDMap[::Incremental] encoding, or the</span></span><br><span class="line">  <span class="comment">// encoding of some type embedded therein (CrushWrapper, something</span></span><br><span class="line">  <span class="comment">// from osd_types, etc.).</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> SIGNIFICANT_FEATURES =</span><br><span class="line">    CEPH_FEATUREMASK_PGID64 |</span><br><span class="line">    CEPH_FEATUREMASK_PGPOOL3 |</span><br><span class="line">    CEPH_FEATUREMASK_OSDENC |</span><br><span class="line">    CEPH_FEATUREMASK_OSDMAP_ENC |</span><br><span class="line">    CEPH_FEATUREMASK_OSD_POOLRESEND |</span><br><span class="line">    CEPH_FEATUREMASK_NEW_OSDOP_ENCODING |</span><br><span class="line">    CEPH_FEATUREMASK_MSG_ADDR2 |</span><br><span class="line">    CEPH_FEATUREMASK_CRUSH_TUNABLES5 |</span><br><span class="line">    CEPH_FEATUREMASK_CRUSH_CHOOSE_ARGS |</span><br><span class="line">    CEPH_FEATUREMASK_SERVER_LUMINOUS |</span><br><span class="line">    CEPH_FEATUREMASK_SERVER_MIMIC |</span><br><span class="line">    CEPH_FEATUREMASK_SERVER_NAUTILUS;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">addrs_s</span> &#123;</span><br><span class="line">    mempool::osdmap::vector&lt;std::shared_ptr&lt;<span class="type">entity_addrvec_t</span>&gt; &gt; client_addrs;</span><br><span class="line">    mempool::osdmap::vector&lt;std::shared_ptr&lt;<span class="type">entity_addrvec_t</span>&gt; &gt; cluster_addrs;</span><br><span class="line">    mempool::osdmap::vector&lt;std::shared_ptr&lt;<span class="type">entity_addrvec_t</span>&gt; &gt; hb_back_addrs;</span><br><span class="line">    mempool::osdmap::vector&lt;std::shared_ptr&lt;<span class="type">entity_addrvec_t</span>&gt; &gt; hb_front_addrs;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  std::shared_ptr&lt;addrs_s&gt; osd_addrs;    <span class="comment">//OSD的地址</span></span><br><span class="line">  <span class="type">entity_addrvec_t</span> _blank_addrvec;</span><br><span class="line">  mempool::osdmap::vector&lt;__u32&gt;   osd_weight;   <span class="comment">//OSD的权重 16.16 fixed point, 0x10000 = &quot;in&quot;, 0 = &quot;out&quot;</span></span><br><span class="line">  mempool::osdmap::vector&lt;<span class="type">osd_info_t</span>&gt; osd_info;    <span class="comment">//OSD 的基本信息</span></span><br><span class="line">  std::shared_ptr&lt; mempool::osdmap::vector&lt;uuid_d&gt; &gt; osd_uuid;  <span class="comment">//OSD对应的uuid</span></span><br><span class="line">  mempool::osdmap::vector&lt;<span class="type">osd_xinfo_t</span>&gt; osd_xinfo;   <span class="comment">//OSD一些扩展信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//PG相关的信息</span></span><br><span class="line">  std::shared_ptr&lt;PGTempMap&gt; pg_temp;  <span class="comment">// temp pg mapping (e.g. while we rebuild)</span></span><br><span class="line">  std::shared_ptr&lt; mempool::osdmap::map&lt;<span class="type">pg_t</span>,<span class="type">int32_t</span> &gt; &gt; primary_temp;  <span class="comment">// temp primary mapping (e.g. while we rebuild)</span></span><br><span class="line">  std::shared_ptr&lt; mempool::osdmap::vector&lt;__u32&gt; &gt; osd_primary_affinity; <span class="comment">///&lt; 16.16 fixed point, 0x10000 = baseline</span></span><br><span class="line">  <span class="comment">// remap (post-CRUSH, pre-up)</span></span><br><span class="line">  mempool::osdmap::map&lt;<span class="type">pg_t</span>,mempool::osdmap::vector&lt;<span class="type">int32_t</span>&gt;&gt; pg_upmap; <span class="comment">///&lt; remap pg</span></span><br><span class="line">  mempool::osdmap::map&lt;<span class="type">pg_t</span>,mempool::osdmap::vector&lt;pair&lt;<span class="type">int32_t</span>,<span class="type">int32_t</span>&gt;&gt;&gt; pg_upmap_items; <span class="comment">///&lt; remap osds in up set</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//pool的相关信息</span></span><br><span class="line">  mempool::osdmap::map&lt;<span class="type">int64_t</span>,<span class="type">pg_pool_t</span>&gt; pools;   <span class="comment">//pool的id到pg_pool_t的映射</span></span><br><span class="line">  mempool::osdmap::map&lt;<span class="type">int64_t</span>,string&gt; pool_name;  <span class="comment">//pool的id到pool的名字的映射</span></span><br><span class="line">  mempool::osdmap::map&lt;string,map&lt;string,string&gt; &gt; erasure_code_profiles;    <span class="comment">//pool的EC相关信息</span></span><br><span class="line">  mempool::osdmap::map&lt;string,<span class="type">int64_t</span>&gt; name_pool;  <span class="comment">//pool的名字到pool的id的映射</span></span><br></pre></td></tr></table></figure><h2 id="Op"><a href="#Op" class="headerlink" title="Op"></a>Op</h2><p><code>结构体Op</code>封装了完成一个操作的相关上下文信息，包括target地址信息(op_target_t)、链接信息(session)等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Op封装了完成一个操作的相关的上下文信息，包括target地址信息、链接信息等。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Op</span> : <span class="keyword">public</span> RefCountedObject &#123;</span><br><span class="line">    OSDSession *session;   <span class="comment">//OSD相关的Session信息 </span></span><br><span class="line">    <span class="type">int</span> incarnation;    <span class="comment">//引用次数</span></span><br><span class="line">    <span class="type">op_target_t</span> target;   <span class="comment">//地址信息</span></span><br><span class="line">    ConnectionRef con;  <span class="comment">// for rx buffer only</span></span><br><span class="line">    <span class="type">uint64_t</span> features;  <span class="comment">// explicitly specified op features</span></span><br><span class="line">    vector&lt;OSDOp&gt; ops;   <span class="comment">// 对应多个操作的封装</span></span><br><span class="line">    <span class="type">snapid_t</span> snapid;     <span class="comment">//快照的ID</span></span><br><span class="line">    SnapContext snapc;   <span class="comment">//pool层级的快照信息</span></span><br><span class="line">    ceph::real_time mtime;</span><br><span class="line">    bufferlist *outbl;    <span class="comment">//输出的bufferlist</span></span><br><span class="line">    vector&lt;bufferlist*&gt; out_bl;     <span class="comment">//每个操作对应的bufferlist</span></span><br><span class="line">    vector&lt;Context*&gt; out_handler;    <span class="comment">//每个操作对应的回调函数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>*&gt; out_rval;     <span class="comment">//每个操作对应的输出结果</span></span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    Context *onfinish;</span><br><span class="line">    <span class="type">uint64_t</span> ontimeout;</span><br><span class="line">    <span class="type">ceph_tid_t</span> tid;</span><br><span class="line">    <span class="type">int</span> attempts;</span><br><span class="line">    <span class="type">version_t</span> *objver;</span><br><span class="line">    <span class="type">epoch_t</span> *reply_epoch;</span><br><span class="line">    ceph::coarse_mono_time stamp;</span><br><span class="line">    <span class="type">epoch_t</span> map_dne_bound;</span><br><span class="line">    <span class="type">int</span> budget;</span><br><span class="line">    <span class="comment">/// true if we should resend this message on failure</span></span><br><span class="line">    <span class="type">bool</span> should_resend;</span><br><span class="line">    <span class="comment">/// true if the throttle budget is get/put on a series of OPs,</span></span><br><span class="line">    <span class="comment">/// instead of per OP basis, when this flag is set, the budget is</span></span><br><span class="line">    <span class="comment">/// acquired before sending the very first OP of the series and</span></span><br><span class="line">    <span class="comment">/// released upon receiving the last OP reply.</span></span><br><span class="line">    <span class="type">bool</span> ctx_budgeted;</span><br><span class="line">    <span class="type">int</span> *data_offset;</span><br><span class="line"></span><br><span class="line">    <span class="type">osd_reqid_t</span> reqid; <span class="comment">// explicitly setting reqid</span></span><br><span class="line">    ZTracer::Trace trace;</span><br></pre></td></tr></table></figure><h2 id="op-target-t"><a href="#op-target-t" class="headerlink" title="op_target_t"></a>op_target_t</h2><p>数据结构op_target_t封装了对象所在的PG，以及PG对应的OSD列表等地址信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装了对象所在的PG，以及PG对应的OSD列表等地址信息</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">op_target_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="number">0</span>;    <span class="comment">//标志</span></span><br><span class="line">    <span class="type">epoch_t</span> epoch = <span class="number">0</span>;  <span class="comment">///&lt; latest epoch we calculated the mapping</span></span><br><span class="line">    <span class="type">object_t</span> base_oid;   <span class="comment">//读取的对象</span></span><br><span class="line">    <span class="type">object_locator_t</span> base_oloc;   <span class="comment">//对象的pool信息</span></span><br><span class="line">    <span class="type">object_t</span> target_oid;     <span class="comment">//最终读取的目标对象</span></span><br><span class="line">    <span class="type">object_locator_t</span> target_oloc;   <span class="comment">//最终目标对象的pool信息</span></span><br><span class="line">    <span class="comment">///&lt; true if we are directed at base_pgid, not base_oid</span></span><br><span class="line">    <span class="type">bool</span> precalc_pgid = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">///&lt; true if we have ever mapped to a valid pool</span></span><br><span class="line">    <span class="type">bool</span> pool_ever_existed = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">///&lt; explcit pg target, if any</span></span><br><span class="line">    <span class="type">pg_t</span> base_pgid;</span><br><span class="line">    <span class="type">pg_t</span> pgid; <span class="comment">///&lt; last (raw) pg we mapped to</span></span><br><span class="line">    <span class="type">spg_t</span> actual_pgid; <span class="comment">///&lt; last (actual) spg_t we mapped to</span></span><br><span class="line">    <span class="type">unsigned</span> pg_num = <span class="number">0</span>; <span class="comment">///&lt; last pg_num we mapped to</span></span><br><span class="line">    <span class="type">unsigned</span> pg_num_mask = <span class="number">0</span>; <span class="comment">///&lt; last pg_num_mask we mapped to</span></span><br><span class="line">    <span class="type">unsigned</span> pg_num_pending = <span class="number">0</span>; <span class="comment">///&lt; last pg_num we mapped to</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; up; <span class="comment">///&lt; set of up osds for last pg we mapped to</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; acting; <span class="comment">///&lt; set of acting osds for last pg we mapped to</span></span><br><span class="line">    <span class="type">int</span> up_primary = <span class="number">-1</span>; <span class="comment">///&lt; last up_primary we mapped to</span></span><br><span class="line">    <span class="type">int</span> acting_primary = <span class="number">-1</span>;  <span class="comment">///&lt; last acting_primary we mapped to</span></span><br><span class="line">    <span class="type">int</span> size = <span class="number">-1</span>; <span class="comment">///&lt; the size of the pool when were were last mapped</span></span><br><span class="line">    <span class="type">int</span> min_size = <span class="number">-1</span>; <span class="comment">///&lt; the min size of the pool when were were last mapped</span></span><br><span class="line">    <span class="type">bool</span> sort_bitwise = <span class="literal">false</span>; <span class="comment">///&lt; whether the hobject_t sort order is bitwise</span></span><br><span class="line">    <span class="type">bool</span> recovery_deletes = <span class="literal">false</span>; <span class="comment">///&lt; whether the deletes are performed during recovery instead of peering</span></span><br><span class="line">    <span class="type">bool</span> used_replica = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> paused = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> osd = <span class="number">-1</span>;      <span class="comment">///&lt; the final target osd, or -1</span></span><br><span class="line">    <span class="type">epoch_t</span> last_force_resend = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="CRUSH-Map"><a href="#CRUSH-Map" class="headerlink" title="CRUSH Map"></a>CRUSH Map</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_rule_step</span> &#123;</span><br><span class="line">__u32 op;    <span class="comment">//操作类型</span></span><br><span class="line">__s32 arg1;   <span class="comment">//操作数1</span></span><br><span class="line">__s32 arg2;    <span class="comment">//操作数2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">crush_opcodes</span> &#123;</span><br><span class="line">CRUSH_RULE_NOOP = <span class="number">0</span>,</span><br><span class="line">CRUSH_RULE_TAKE = <span class="number">1</span>,          <span class="comment">/* arg1 = value to start with */</span></span><br><span class="line">CRUSH_RULE_CHOOSE_FIRSTN = <span class="number">2</span>, <span class="comment">/* arg1 = num items to pick */</span> <span class="comment">/* arg2 = type */</span>      </span><br><span class="line">CRUSH_RULE_CHOOSE_INDEP = <span class="number">3</span>,  <span class="comment">/* same */</span></span><br><span class="line">CRUSH_RULE_EMIT = <span class="number">4</span>,          <span class="comment">/* no args */</span></span><br><span class="line">CRUSH_RULE_CHOOSELEAF_FIRSTN = <span class="number">6</span>,</span><br><span class="line">CRUSH_RULE_CHOOSELEAF_INDEP = <span class="number">7</span>,</span><br><span class="line">CRUSH_RULE_SET_CHOOSE_TRIES = <span class="number">8</span>, <span class="comment">/* override choose_total_tries */</span></span><br><span class="line">CRUSH_RULE_SET_CHOOSELEAF_TRIES = <span class="number">9</span>, <span class="comment">/* override chooseleaf_descend_once */</span></span><br><span class="line">CRUSH_RULE_SET_CHOOSE_LOCAL_TRIES = <span class="number">10</span>,</span><br><span class="line">CRUSH_RULE_SET_CHOOSE_LOCAL_FALLBACK_TRIES = <span class="number">11</span>,</span><br><span class="line">CRUSH_RULE_SET_CHOOSELEAF_VARY_R = <span class="number">12</span>,</span><br><span class="line">CRUSH_RULE_SET_CHOOSELEAF_STABLE = <span class="number">13</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用于指定相对于传递给 do_rule 的 max 参数的选择 num (arg1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRUSH_CHOOSE_N            0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRUSH_CHOOSE_N_MINUS(x)   (-(x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 规则掩码用于描述规则的用途。</span></span><br><span class="line"><span class="comment"> * 给定规则集和输出集的大小，我们在规则列表中搜索匹配的 rule_mask。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_rule_mask</span> &#123;</span><br><span class="line">__u8 ruleset;   <span class="comment">//ruleId</span></span><br><span class="line">__u8 type;   <span class="comment">//多副本还是纠删码</span></span><br><span class="line">__u8 min_size;   <span class="comment">//副本数大于等于时适用</span></span><br><span class="line">__u8 max_size;   <span class="comment">//副本数小于等于时适用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_rule</span> &#123;</span><br><span class="line">__u32 len;   <span class="comment">//steps数组的长度</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_rule_mask</span> mask;   <span class="comment">//releset相关的配置参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_rule_step</span> steps[<span class="number">0</span>];   <span class="comment">//step集合</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> crush_rule_size(len) (sizeof(struct crush_rule) + \</span></span><br><span class="line"><span class="meta">      (len)*sizeof(struct crush_rule_step))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A bucket is a named container of other items (either devices or</span></span><br><span class="line"><span class="comment"> * other buckets).</span></span><br><span class="line"><span class="comment"> * 桶是其他item（设备或其他存储桶）的命名容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用三种算法中的一种来选择的，这些算法代表了性能和重组效率之间的权衡。 </span></span><br><span class="line"><span class="comment"> * 如果您不确定要使用哪种存储桶类型，我们建议您使用 ::CRUSH_BUCKET_STRAW2。</span></span><br><span class="line"><span class="comment"> * 该表总结了在添加或删除item时每个选项的速度如何与映射稳定性相比较。</span></span><br><span class="line"><span class="comment"> * Bucket Alg     Speed       Additions    Removals</span></span><br><span class="line"><span class="comment"> * ------------------------------------------------</span></span><br><span class="line"><span class="comment"> * uniform         O(1)       poor         poor</span></span><br><span class="line"><span class="comment"> * list            O(n)       optimal      poor</span></span><br><span class="line"><span class="comment"> * straw2          O(n)       optimal      optimal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">crush_algorithm</span> &#123;</span><br><span class="line">CRUSH_BUCKET_UNIFORM = <span class="number">1</span>,</span><br><span class="line">CRUSH_BUCKET_LIST = <span class="number">2</span>,</span><br><span class="line">CRUSH_BUCKET_TREE = <span class="number">3</span>,</span><br><span class="line">CRUSH_BUCKET_STRAW = <span class="number">4</span>,</span><br><span class="line">CRUSH_BUCKET_STRAW2 = <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">crush_bucket_alg_name</span><span class="params">(<span class="type">int</span> alg)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRUSH_LEGACY_ALLOWED_BUCKET_ALGS (\</span></span><br><span class="line"><span class="meta">(1 &lt;&lt; CRUSH_BUCKET_UNIFORM) |\</span></span><br><span class="line"><span class="meta">(1 &lt;&lt; CRUSH_BUCKET_LIST) |\</span></span><br><span class="line"><span class="meta">(1 &lt;&lt; CRUSH_BUCKET_STRAW))</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_bucket</span> &#123;</span><br><span class="line">__s32 id;       <span class="comment">//bucket的编号。小于0 /*!&lt; bucket identifier, &lt; 0 and unique within a crush_map */</span></span><br><span class="line">__u16 type;      <span class="comment">//bucket的类型/*!&lt; &gt; 0 bucket type, defined by the caller */</span></span><br><span class="line">__u8 alg;        <span class="comment">//使用的crush算法/*!&lt; the item selection ::crush_algorithm */</span></span><br><span class="line">__u8 hash;       <span class="comment">//使用的hash算法/* which hash function to use, CRUSH_HASH_* */</span></span><br><span class="line">__u32 weight;   <span class="comment">//权重 /*!&lt; 16.16 fixed point cumulated children weight */</span></span><br><span class="line">__u32 size;      <span class="comment">//items的数量/*!&lt; size of the __items__ array */</span></span><br><span class="line">    __s32 *items;    <span class="comment">//子bucket/*!&lt; array of children: &lt; 0 are buckets, &gt;= 0 items */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_weight_set</span> &#123;</span><br><span class="line">  __u32 *weights; <span class="comment">/*!&lt; 16.16 fixed point weights in the same order as items */</span></span><br><span class="line">  __u32 size;     <span class="comment">/*!&lt; size of the __weights__ array */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_choose_arg</span> &#123;</span><br><span class="line">  __s32 *ids;                           <span class="comment">/*!&lt; values to use instead of items */</span></span><br><span class="line">  __u32 ids_size;                       <span class="comment">/*!&lt; size of the __ids__ array */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">crush_weight_set</span> *weight_set;  <span class="comment">/*!&lt; weight replacements for a given position */</span></span><br><span class="line">  __u32 weight_set_positions;           <span class="comment">/*!&lt; size of the __weight_set__ array */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_choose_arg_map</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">crush_choose_arg</span> *args; <span class="comment">/*!&lt; replacement for each bucket in the crushmap */</span></span><br><span class="line">  __u32 size;                    <span class="comment">/*!&lt; size of the __args__ array */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_bucket_uniform</span> &#123;</span><br><span class="line">       <span class="keyword">struct</span> <span class="title class_">crush_bucket</span> h; <span class="comment">/*!&lt; generic bucket information */</span></span><br><span class="line">__u32 item_weight;  <span class="comment">/*!&lt; 16.16 fixed point weight for each item */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_bucket_list</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">crush_bucket</span> h; <span class="comment">/*!&lt; generic bucket information */</span></span><br><span class="line">__u32 *item_weights;  <span class="comment">/*!&lt; 16.16 fixed point weight for each item */</span></span><br><span class="line">__u32 *sum_weights;   <span class="comment">/*!&lt; 16.16 fixed point sum of the weights */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_bucket_tree</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_bucket</span> h;  <span class="comment">/* note: h.size is _tree_ size, not number of</span></span><br><span class="line"><span class="comment">   actual items */</span></span><br><span class="line">__u8 num_nodes;</span><br><span class="line">__u32 *node_weights;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_bucket_straw</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_bucket</span> h;</span><br><span class="line">__u32 *item_weights;   <span class="comment">/* 16-bit fixed point */</span></span><br><span class="line">__u32 *straws;         <span class="comment">/* 16-bit fixed point */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_bucket_straw2</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">crush_bucket</span> h; <span class="comment">/*!&lt; generic bucket information */</span></span><br><span class="line">__.  <span class="comment">/*!&lt; 16.16 fixed point weight for each item */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_map</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_bucket</span> **buckets;  **类型，所有的bucket都存在这里</span><br><span class="line">        <span class="comment">/*! 一个大小为__max_rules__ 的crush_rule 指针数组。</span></span><br><span class="line"><span class="comment">         * 如果规则被删除，数组的一个元素可能为NULL（没有API 可以这样做，但将来可能会有一个）。 </span></span><br><span class="line"><span class="comment">         * 规则必须使用crunch_add_rule() 添加。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">crush_rule</span> **rules;   <span class="comment">//**类型，多层嵌套的rules</span></span><br><span class="line">    __s32 max_buckets; <span class="comment">/*!&lt; the size of __buckets__ */</span>  <span class="comment">// bucket的总数</span></span><br><span class="line">__u32 max_rules; <span class="comment">/*!&lt; the size of __rules__ */</span>      <span class="comment">// rule的总数</span></span><br><span class="line">__s32 max_devices;   <span class="comment">// osd的总数</span></span><br><span class="line">__u32 choose_local_tries;   <span class="comment">//选择的总次数</span></span><br><span class="line">__u32 choose_local_fallback_tries;  </span><br><span class="line">__u32 choose_total_tries;</span><br><span class="line">__u32 chooseleaf_descend_once;</span><br><span class="line">__u8 chooseleaf_vary_r;</span><br><span class="line">__u8 chooseleaf_stable;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">该值是在构建器解码或构建后计算的。 它在此处公开（而不是具有“构建 CRUSH 工作空间”功能），以便调用者可以保留静态缓冲区、在堆栈上分配空间，或者在需要时避免调用堆分配器。 </span></span><br><span class="line"><span class="comment">        工作空间的大小取决于映射，而传递给映射器的临时向量的大小取决于所需结果集的大小。尽管如此，没有什么能阻止调用者在一个膨胀 foop 中分配两个点并传递两个点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">size_t</span> working_size;</span><br></pre></td></tr></table></figure><p><img src="/images/Ceph%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Ceph-相关数据结构&quot;&gt;&lt;a href=&quot;#Ceph-相关数据结构&quot; class=&quot;headerlink&quot; title=&quot;Ceph 相关数据结构&quot;&gt;&lt;/a&gt;Ceph 相关数据结构&lt;/h2&gt;&lt;p&gt;要想深入到Ceph的源码底层，就必须对代码通用库里的一些关键，常见的</summary>
      
    
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/categories/%E4%BA%91%E5%AD%98%E5%82%A8/Ceph/"/>
    
    
    <category term="云存储" scheme="https://watsonlu6.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"/>
    
    <category term="Ceph" scheme="https://watsonlu6.github.io/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://watsonlu6.github.io/hello-world/"/>
    <id>https://watsonlu6.github.io/hello-world/</id>
    <published>2023-07-11T15:09:26.000Z</published>
    <updated>2024-07-13T15:58:33.946Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
